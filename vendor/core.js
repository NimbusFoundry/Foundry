
// Generated by CoffeeScript 1.8.0

/*
 core code
 */

(function() {
  var core;

  core = new Object();

  core._plugins = {};

  core._workspace = {};

  core._models = {};

  core.angular = {
    dependency: []
  };

  core.loaded = false;

  core.bootstraped = false;

  core.default_plugin = '';

  window.create_object_dictionary = function(all) {
    var dict, obj, _i, _len;
    dict = {};
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      obj = all[_i];
      dict[obj.id] = obj;
    }
    return dict;
  };

  if (Nimbus.Client.GDrive.is_auth_redirected()) {
    $("#login_buttons").addClass("redirect");
  }

  core.current_user = function(callback) {
    var self;
    self = this;
    return Nimbus.Share.get_me(function(me) {
      console.log(me);
      self._current_user = me;
      if (!self._current_user.email) {
        self._current_user.email = Nimbus.Share.get_user_email();
      }
      if (callback) {
        callback(me);
      }
      $("#user_pic").attr("src", me.pic);
      return $("#user_pic_large").attr("src", me.pic);
    });
  };

  core.shared_users = function(callback) {
    var self;
    self = this;
    return Nimbus.Share.get_shared_users_real(function(users) {
      console.log(users);
      self._user_list = window.create_object_dictionary(users);
      if (callback) {
        return callback(users);
      }
    });
  };


  /*
   separate plugin loading form init process to accerate the app time
   */

  core.plugins_loaded = false;

  core.load_plugins = function() {
    var self;
    self = this;
    return require(['core'], function(main) {
      self.plugins_loaded = true;
      return require(main.plugins, function() {
        var dependency, plugin, _i, _len;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          plugin = arguments[_i];
          self._plugins[plugin.name] = plugin;
        }
        dependency = self.angular.dependency.concat(['foundry-ui', 'ngRoute']);
        angular.module('foundry', dependency).config([
          '$routeProvider', function($routeProvider) {
            var path, route, _ref;
            _ref = main.paths;
            for (route in _ref) {
              path = _ref[route];
              $routeProvider.when('/' + route, {
                templateUrl: path + '.html'
              });
            }
          }
        ]).run([
          '$rootScope', '$location', function($rootScope, $location) {
            var inex, _plugin, _ref;
            $rootScope._plugins = [];
            _ref = foundry._plugins;
            for (inex in _ref) {
              _plugin = _ref[inex];
              $rootScope._plugins.push(_plugin);
            }
            $rootScope._active_app_path = '';
            $rootScope._current_global_user = foundry._current_user;
            $rootScope.$on('$locationChangeSuccess', function(evt, new_path, old_path) {
              var default_path;
              default_path = localStorage.default_plugin || foundry.default_plugin;
              if (default_path && !$location.path()) {
                $location.path(default_path);
              } else if (!$location.path()) {
                $location.path('/workspace');
              }
              $rootScope._active_app_path = $location.path();
              localStorage.default_plugin = $location.path();
            });
          }
        ]);
        console.log('plugins loaded');
        return self.plugin_load_completed();
      });
    });
  };

  define('core', ['config'], function(config) {
    var c, key, packages, paths, plugins, value, _ref;
    console.log(config);
    paths = {};
    plugins = [];
    packages = [];
    _ref = config.plugins;
    for (key in _ref) {
      value = _ref[key];
      paths[key] = value + '/index';
      plugins.push(key);
      packages.push({
        name: key,
        location: value,
        main: 'index'
      });
    }
    requirejs.config({
      'packages': packages
    });
    c = {
      'plugins': plugins,
      'paths': paths,
      'packages': packages,
      'appName': config.appName
    };
    return c;
  });

  core.plugin_load_completed = function() {
    return console.log('plugins is loaded');
  };

  core.init = function(callback) {
    var cb, plugin_completed, self;
    self = this;
    cb = function() {
      var key, value, _ref;
      self.init_settings();
      _ref = self._plugins;
      for (key in _ref) {
        value = _ref[key];
        if (typeof value.inited === 'function') {
          value.inited();
        }
      }
      if (!self.bootstraped) {
        angular.bootstrap(document, ['foundry']);
        self.bootstraped = true;
      }
      if (callback) {
        callback();
      }
    };
    if (this.plugins_loaded) {
      console.log('plugins loaded, and start the callback');
      this.reinitialize(cb);
    } else {
      console.log('not yet, put the callback into the plugin_callbak');
      plugin_completed = this.plugin_load_completed;
      this.plugin_load_completed = function() {
        plugin_completed();
        return self.reinitialize(cb);
      };
    }
  };

  core.module_status = {};

  core.reinitialize = function(callback) {
    var e, k, v, _ref, _ref1;
    if (callback) {
      this.module_finished = callback;
    }
    _ref = this._plugins;
    for (k in _ref) {
      v = _ref[k];
      if (v.type === 'plugin') {
        this.module_status[v.name] = 'start';
      }
    }
    _ref1 = this._plugins;
    for (k in _ref1) {
      v = _ref1[k];
      if (v.type === 'plugin') {
        try {
          v.init();
        } catch (_error) {
          e = _error;
          console.log(e);
        }
      }
    }
  };

  core.initialized = function(module) {
    var k, v, _ref;
    this.module_status[module] = 'end';
    console.log(this.module_status);
    _ref = this._plugins;
    for (k in _ref) {
      v = _ref[k];
      if (this.module_status[v.name] === 'start') {
        return;
      }
    }
    if (this.module_finished) {
      return this.module_finished();
    }
  };

  core.ready = function(callback) {
    var self;
    self = this;
    return Nimbus.Auth.set_app_ready(function() {
      callback();
      return self.loaded = true;
    });
  };

  core.model = function(name, attributes, callback) {
    var model, self, sync_finished;
    self = this;
    if (name && attributes) {
      model = Nimbus.Model.setup(name, attributes);
      self._models[name] = model;
      sync_finished = function() {
        return callback(model);
      };
      model.sync_all(sync_finished);
      return model;
    } else {
      throw 'Model name and attributes should be specified';
      return void 0;
    }
  };

  core.module = function(name, obj, callback) {
    var name_used;
    name_used = false;
    if (!core._plugins[name]) {
      core._plugins[name] = obj;
    } else {
      name_used = true;
    }
    callback(!name_used);
    return console.log('register ' + (!name_used ? 'ok' : 'failed'));
  };

  core.load = function(name) {
    return this._plugins[name];
  };

  core.load_model = function(name) {
    return this._models[name];
  };

  core.logout = function() {
    return Nimbus.Auth.logout();
  };


  /*
  	parse context within url
   */

  core.parse_open_url = function() {
    var config, e, m, open_setting, regex, string;
    config = {};
    string = decodeURIComponent(location.search.substring(1)).replace('/', '');
    regex = /([^&=]+)=([^&]*)/g;
    while (m = regex.exec(string)) {
      config[m[1]] = m[2];
    }
    if (config.state) {
      try {
        open_setting = JSON.parse(config.state);
        if (open_setting) {
          localStorage.login_user = open_setting.userId;
          if (open_setting.ids[0]) {
            localStorage.last_opened_workspace = open_setting.ids[0];
          }
        }
      } catch (_error) {
        e = _error;
        console.log(e);
      }
    } else if (config.space) {
      localStorage.last_opened_workspace = config.space;
      localStorage.to_open_topic = config.topic;
    }
    return config;
  };

  core.parse_open_url();


  /*
  	function: initialize the setting
   */

  core.init_settings = function() {
    return core.settings = core.model("Settings", ["userid", "setting_name", "setting_value"], function(model) {
      core.settings = model;
      return core._my_settings = model.findByAttribute("userid", core._current_user.id);
    });
  };


  /*
  	input: the key and the value to set
  	function: set the setting
   */

  core.set_setting = function(key, value) {
    var my_settings, x;
    my_settings = foundry.settings.select(function(item) {
      return item.userid === foundry._current_user.id && item.setting_name === key;
    });
    if (my_settings.length === 0) {
      return foundry.settings.create({
        "userid": foundry._current_user.id,
        "setting_name": key,
        "setting_value": value
      });
    } else {
      x = my_settings[0];
      x.setting_value = value;
      return x.save();
    }
  };


  /*
  	input: the key for the setting to retrieve
  	output: the value of the key
  	function: output a setting
   */

  core.get_setting = function(key) {
    var setting;
    setting = foundry.settings.select(function(item) {
      return item.userid === foundry._current_user.id && item.setting_name === key;
    });
    if (setting.length > 0) {
      return setting[0].setting_value;
    } else {
      return null;
    }
  };

  core.get_setting_all = function(userid, key) {
    var setting;
    setting = foundry.settings.select(function(item) {
      return item.userid === userid && item.setting_name === key;
    });
    if (setting.length > 0) {
      return setting[0].setting_value;
    } else {
      return null;
    }
  };

  core.set_file_public = function(id, callback) {
    var param;
    param = {
      body: {
        role: 'reader',
        type: 'anyone'
      },
      path: "/drive/v2/files/" + id + "/permissions",
      params: {
        fileId: id
      },
      method: "POST",
      callback: function(data) {
        log(data);
        if (callback) {
          return callback(data);
        }
      }
    };
    return gapi.client.request(param);
  };

  window.foundry = core;

}).call(this);

(function(i, s, o, g, r, a, m) {
	i['GoogleAnalyticsObject'] = r;
	i[r] = i[r] ||
	function() {
		(i[r].q = i[r].q || []).push(arguments)
	}, i[r].l = 1 * new Date();
	a = s.createElement(o), m = s.getElementsByTagName(o)[0];
	a.async = 1;
	a.src = g;
	m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

(function(){define("core/analytic",function(){var e,n,r,i,o,t;return r=function(){var e;return ga("create","UA-46950334-2",{userId:foundry._current_user.email}),ga("require","displayfeatures"),ga("set","dimension1",foundry._current_user.email),ga("set","dimension2",c_file.title),ga("set","dimension3",c_file.owners[0].emailAddress+":"+c_file.owners[0].displayName),e=foundry._models.User.all(),ga("set","dimension4",e),ga("send","pageview")},n=function(){var e,n,r,i,o;for(e=0,o=window.app_files,r=0,i=o.length;i>r;r++)n=o[r],n.owners[0].permissionId===foundry._current_user.id&&e++;return e},o=function(e){var r;if(ga)return r=n(),ga("send","event","forum_owner_operation:"+e.email,"create_workspace:"+e.name,r)},t=function(e){var n;if(ga)return n=foundry._models.User.all().length,ga("send","event","forum_owner_operation:"+e.email,"share_workspace:"+e.user,n)},i=function(e){},e={init:function(){return r()},owner:function(e){return o(e)},user:function(e){return t(e)},login:function(e){return i(e)}}})}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var define_controller;

  define('document', function(require) {
    var doc_plugin;
    return doc_plugin = {
      type: 'plugin',
      title: 'Document',
      anchor: '#/document',
      name: 'document',
      version: 1.0,
      order: -10,
      icon: 'icon-file',
      controller_scope: null,
      init: function() {
        var attributes, name, self;
        self = this;
        name = 'Document';
        attributes = ["id", "title", "timestamp"];
        foundry.model(name, attributes, function(model) {
          model.onUpdate(function(mode, obj, isLocal) {
            if (mode === 'CREATE' && !isLocal) {
              return self.all_file(function() {
                if (self.controller_scope) {
                  self.controller_scope.load();
                  return self.controller_scope.$apply();
                }
              });
            }
          });
          return self.all_file(function() {
            return foundry.initialized(self.name);
          });
        });
        define_controller();
      },
      all_file: function(callback) {
        var self;
        self = this;
        if (folder) {
          return Nimbus.Client.GDrive.getMetadataList("'" + folder.binary_files.id + "' in parents", function(data) {
            self._documents = window.create_object_dictionary(data.items);
            if (callback) {
              callback(data.items);
            }
          });
        } else {
          return [];
        }
      },
      upload_file: function(file, callback) {
        return Nimbus.Binary.upload_file(file, function(f) {
          if (callback) {
            return callback(f);
          }
        });
      },
      delete_file: function(doc, callback) {
        var model;
        Nimbus.Client.GDrive.deleteFile(doc.id);
        delete this._documents[doc.id];
        model = foundry._models.Document;
        doc = model.findByAttribute('id', doc.id);
        if (doc) {
          doc.destroy();
        }
        if (callback) {
          return callback();
        }
      },
      get: function(id) {
        return this._documents[id];
      },
      set: function(id, data) {
        var doc, model;
        if (!this._documents[id]) {
          this._documents[id] = data;
          model = foundry._models.Document;
          doc = model.create({
            title: data.title,
            id: data.id,
            timestamp: new Date().getTime()
          });
          doc.save();
        }
      }
    };
  });

  define_controller = function() {
    return angular.module('foundry').controller('DocumentController', [
      '$scope', '$rootScope', 'ngDialog', '$foundry', '$timeout', function($scope, $rootScope, ngDialog, $foundry, $timeout) {
        var file_module;
        $rootScope.breadcum = 'Documents';
        file_module = foundry.load('document');
        file_module.controller_scope = $scope;
        $scope.load = function(callback) {
          $scope.files = file_module._documents;
          if (callback) {
            callback();
          }
        };
        $scope.choosed_file = null;
        $scope.upload_document = function() {
          var spinner;
          spinner = $foundry.spinner({
            type: 'loading',
            text: 'Uploading '
          });
          Nimbus.Binary.upload_file($scope.choosed_file, function(file) {
            file_module.set(file._file.id, file._file);
            $scope.choosed_file = null;
            $scope.load();
            $scope.$apply();
            return spinner.hide();
          });
        };
        $scope.delete_document = function(file) {
          var spinner;
          spinner = $foundry.spinner({
            type: 'loading',
            text: 'Deleteing...'
          });
          return file_module.delete_file(file, function() {
            console.log('deleting file');
            return $timeout(function() {
              return $scope.load(function() {
                return spinner.hide();
              });
            }, 3000);
          });
        };
        $scope.load();
      }
    ]);
  };

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  var inject_controller;

  define('user', ['require', 'core/analytic'], function(require, analytic) {
    var user_plugin;
    return user_plugin = {
      name: 'user',
      _models: {},
      anchor: '#/user',
      title: 'Users',
      type: 'plugin',
      order: -12,
      icon: 'icon-user',
      init: function() {
        var attributes, name, self;
        self = this;
        name = 'User';
        attributes = ['pid', 'name', 'role', 'email', 'pic', 'not_first_login', 'initied', 'rated', 'last_login_time'];
        this._models['user'] = {};
        foundry.model(name, attributes, function(model) {
          self._models['user'] = model;
          foundry.initialized(self.name);
        });
      },
      inited: function() {
        var id, self, user, user_model, _ref;
        analytic.init();
        this.check_users();
        self = this;
        user_model = foundry._models['User'];
        _ref = foundry._user_list;
        for (id in _ref) {
          user = _ref[id];
          if (user.id === c_file.owners[0].permissionId) {
            foundry._current_owner = user;
          }
        }
        return inject_controller();
      },
      check_users: function() {
        var data, one, pid, user, user_model, _i, _len, _ref, _ref1;
        user_model = foundry._models['User'];
        console.log('user list total :' + keys(foundry._user_list).length + ', user model total: ' + user_model.all().length);
        _ref = user_model.all();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          user = _ref[_i];
          if (!user.email) {
            user.destroy();
          }
        }
        _ref1 = foundry._user_list;
        for (pid in _ref1) {
          user = _ref1[pid];
          one = user_model.findByAttribute('pid', pid);
          if (one) {
            if (one.email) {
              user.email = one.email;
              user.roleName = one.role;
            }
          }
          if (one && !one.pic) {
            one.pic = user.pic;
            one.save();
          } else if (!one) {
            data = {
              'pid': pid,
              'name': user.name,
              'pic': user.pic
            };
            if (user.email) {
              data.email = user.email;
            }
            if (window.c_file.owners[0].permissionId === pid) {
              data.role = 'Admin';
            } else {
              data.role = 'Viewer';
            }
            if (pid === foundry._current_user.id) {
              data.email = window.user_email;
            }
            user_model.create(data);
            user.roleName = data.role;
          }
          one = user_model.findByAttribute('pid', pid);
          if (pid === foundry._current_user.id) {
            if (!one.not_first_login) {
              one.not_first_login = 1;
              one.save();
            }
          }
        }
      },
      all_user: function() {
        return this._models['user'].all();
      },
      add_user: function(data, callback) {
        var model, user;
        if (!data.role) {
          data.role = 'Viewer';
        }
        model = this._models['user'];
        user = model.findByAttribute('email', data.email);
        if (!user) {
          user = model.create(data);
        }
        user.role = data.role;
        user.save();
        this.add_share(user, function(data) {
          if (callback) {
            return callback(data);
          }
        });
        return analytic.user({
          email: foundry._current_user.email,
          user: data.email,
          id: foundry._current_user.id
        });
      },
      add_share: function(user, callback) {
        var model;
        model = this._models['user'];
        if (user.email) {
          Nimbus.Share.add_share_user_real(user.email, function(u) {
            var t;
            if (u.name) {
              t = model.findByAttribute('email', user.email);
              t.name = u.name;
              t.pid = u.id;
              t.pic = u.pic;
              t.save();
            }
            foundry._user_list[u.id] = {
              name: u.name,
              pic: u.pic,
              roleName: user.role,
              email: user.email,
              id: u.id,
              role: u.role
            };
            if (callback) {
              callback(u);
              return angular.element(document).scope().$apply();
            }
          });
          if (folder && folder['binary_files']) {
            return Nimbus.Share.add_share_user_real(user.email, null, folder['binary_files'].id);
          }
        }
      },
      remove_share: function(user) {
        Nimbus.Share.remove_share_user_real(user.id, function(res) {});
      },
      save_user: function(id, data) {
        var user;
        user = foundry._user_list[id];
        user.roleName = data.role;
        user = this._models['user'].findByAttribute('pid', id);
        if (user) {
          user.role = data.role;
          return user.save();
        }
      },
      del_user: function(user, callback) {
        var id;
        id = user.id;
        this.remove_share(user);
        if (callback) {
          return callback();
        }
      },
      mail_list: function() {
        var i, id, recipients, user, _ref;
        recipients = '';
        i = 0;
        _ref = foundry._user_list;
        for (id in _ref) {
          user = _ref[id];
          if (user.email === foundry._current_user.email) {
            continue;
          }
          if ((foundry.get_setting_all(id, "email") != null) && foundry.get_setting_all(id, "email") === false) {
            continue;
          }
          if (i === 0 && user.email) {
            recipients += user.name + ' <' + user.email + '>';
          } else if (user.email) {
            recipients += ',' + user.name + ' <' + user.email + '>';
          }
          i++;
        }
        return recipients;
      }
    };
  });

  inject_controller = function() {
    return angular.module('foundry').controller('UserListController', [
      '$scope', '$rootScope', '$parse', function($scope, $rootScope, $parse) {
        var current_user, update_current_user_permission, user_model;
        user_model = foundry.load('user');
        $scope.users = foundry._user_list;

        /*
        			basic settings
         */
        $rootScope.breadcum = 'Users';
        $rootScope.shortcut_name = 'Add User';
        current_user = foundry._current_user;
        $scope.user_permission = 'Viewer';
        update_current_user_permission = function() {
          var current_user_in_model;
          current_user_in_model = foundry._models.User.findByAttribute('pid', current_user.id);
          if (current_user_in_model) {
            return $scope.user_permission = current_user_in_model.role;
          }
        };
        update_current_user_permission();
        $scope.add_shortcut = function() {
          $scope.form_mode = 'create';
          $('.form').modal();
        };
        $scope.form_mode = 'create';
        $scope.usermodel = {
          fields: {
            email: {
              type: 'input',
              label: 'Email'
            },
            role: {
              type: 'select',
              label: 'Role',
              options: {
                Admin: 'Admin',
                Viewer: 'Viewer'
              }
            }
          },
          create: 'submit()',
          update: 'update()'
        };
        $scope.userEditModel = {
          fields: {
            role: {
              type: 'select',
              label: 'Role',
              options: {
                Admin: 'Admin',
                Viewer: 'Viewer'
              }
            }
          },
          create: 'submit()',
          update: 'update()'
        };
        $scope.user_data = {
          name: '',
          email: ''
        };

        /*
        			user CURD
         */
        $scope.edit_user = function(id) {
          $scope.form_mode = 'edit';
          $scope.user_data = angular.copy($scope.users[id]);
          $scope.user_data.role = $scope.user_data.roleName;
          $('.update_form').modal();
        };
        $scope.update = function() {
          user_model.save_user($scope.user_data.id, $scope.user_data);
          update_current_user_permission();
          $('.modal').modal('hide');
          $scope.user_data = {};
        };
        $scope.del_user = function(id) {
          user_model.del_user($scope.users[id]);
          return delete foundry._user_list[id];
        };
        $scope.creating_user = false;
        $scope.submit = function() {
          var reset;
          if ($scope.creating_user) {
            return;
          }
          $scope.creating_user = true;
          reset = function() {
            $scope.user_data = {};
            $('.form').modal('hide');
            $('.create_button').removeClass('disabled');
            return $scope.creating_user = false;
          };
          $('.create_button').addClass('disabled');
          user_model.add_user($scope.user_data, function() {
            return reset();
          });
        };
        $scope.user_info = {};
        $scope.show_user = function(id) {
          var user;
          user = $scope.users[id];
          $scope.user_info = {
            'name': user.name,
            'email': user.email
          };
          $('.userinfo').modal();
        };
        $scope.is_owner = function(user) {
          return user.id === foundry._current_owner.id;
        };
        $scope.clear = function() {
          $('.modal').modal('hide');
          $scope.user_data = {};
        };
      }
    ]);
  };

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  var define_controller;

  define('support', function() {
    return {
      name: 'support',
      title: 'Support',
      anchor: '#/support',
      type: 'plugin',
      icon: 'icon-info-sign',
      order: -15,
      init: function() {
        return foundry.initialized(this.name);
      },
      inited: function() {
        return define_controller();
      }
    };
  });

  define_controller = function() {
    var moduleName;
    moduleName = 'foundry';
    if (!foundry) {
      moduleName = 'foundry';
    }
    return angular.module(moduleName).controller('SupportController', [
      '$scope', '$foundry', function($scope, $foundry) {
        var defaultEmail;
        $scope.newTicket = '';
        defaultEmail = 'admin@nimbusfoundry.com';
        return $scope.createTicket = function() {
          var ccEmails, emails, msg, template;
          msg = $scope.newTicket;
          $scope.newTicket = '';
          emails = [];
          if (foundry.supportEmail) {
            emails = foundry.supportEmail.split(',');
          } else {
            emails.push('release@nimbusbase.com');
          }
          Nimbus.Share.add_share_user_real(emails[0], function(user) {
            var data;
            console.log(user);
            data = {
              'id': user.id,
              'email': emails[0],
              'name': user.name,
              'role': 'Admin'
            };
            if (!foundry._user_list[user.id]) {
              return foundry._user_list[user.id] = data;
            }
          });
          template = "<table style='border-collapse:collapse;width:100%;'> <tr> <td style='background: #1fa086;color: #fff;padding: 10px;border: 1px solid #1fa086;width:20%;border-bottom-color:#ddd;'>Workspace Name</td> <td style='border:1px solid #ddd; padding-left: 20px;'>" + c_file.title + "</td> </tr> <tr> <td style='background: #1fa086;color: #fff;padding: 10px;border: 1px solid #1fa086;width:20%;border-bottom-color:#ddd;'>Workspace Owner</td> <td style='border:1px solid #ddd; padding-left: 20px;'>" + foundry._current_owner.email + "</td> </tr> <tr> <td style='background: #1fa086;color: #fff;padding: 10px;border: 1px solid #1fa086;width:20%;border-bottom-color:#ddd;'>Support Subject</td> <td style='border:1px solid #ddd; padding-left: 20px;'>" + msg + "</td> </tr> </table>";
          ccEmails = emails.slice(1).join(',');
          $foundry.gmail('Forum Support', emails[0], template, ccEmails);
          $('#notification').slideDown().delay(3000).slideUp();
        };
      }
    ]);
  };

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  var define_controller;

  define('workspace', ['require', 'core/analytic'], function(require, analytic) {
    var doc_plugin;
    return doc_plugin = {
      type: 'plugin',
      title: 'Workspace',
      anchor: '#/workspace',
      name: 'workspace',
      version: 1.0,
      order: -13,
      icon: 'icon-folder-close',
      _app_files: [],
      _app_folders: [],
      init: function() {
        var self;
        self = this;
        if (localStorage['last_opened_workspace'] && (localStorage['last_opened_workspace'] !== c_file.id)) {
          this.open({
            id: localStorage['last_opened_workspace']
          });
        } else {
          localStorage['last_opened_workspace'] = c_file.id;
          foundry.shared_users(function(users) {
            var _users;
            _users = users;
            return foundry.current_user(function(me) {
              var user, _i, _len;
              for (_i = 0, _len = _users.length; _i < _len; _i++) {
                user = _users[_i];
                if (user.id === me.id) {
                  foundry._current_user.role = user.role;
                }
              }
              if (!foundry._current_user.email) {
                foundry._current_user.email = Nimbus.Share.get_user_email();
              }
              console.log(_users);
              return foundry.initialized(self.name);
            });
          });
        }
        return define_controller();
      },
      inited: function() {
        log('inited');
        if (this.switch_callback) {
          this.switch_callback();
        }
        return console.log(analytic);
      },
      switch_callback: null,
      all_doc: function() {
        var file, files, folders, _i, _len;
        files = [];
        folders = [];
        for (_i = 0, _len = app_files.length; _i < _len; _i++) {
          file = app_files[_i];
          if (file.mimeType && file.mimeType === 'application/vnd.google-apps.drive-sdk.' + Nimbus.Auth.app_id) {
            files.push(file);
          } else {
            folders.push(file);
          }
        }
        this._app_files = files;
        this._app_folders = folders;
        return this._app_files;
      },
      open: function(doc, callback) {
        localStorage['last_opened_workspace'] = doc.id;
        Nimbus.Share.switch_to_app_file_real(doc.id, function() {
          if (callback) {
            callback();
          }
          angular.element(document).scope().$apply();
          ga('set', 'dimension2', c_file.title);
          ga('set', 'dimension3', c_file.owners[0].emailAddress + ':' + c_file.owners[0].displayName);
          ga('set', 'dimension4', foundry._models.User.all());
        });
      },
      create: function(name, callback) {
        var self;
        if (!name) {
          console.log('name required');
        }
        self = this;
        Nimbus.Client.GDrive.insertFile("", name, 'application/vnd.google-apps.drive-sdk', null, function(data) {
          window.app_files.push(data);
          self._app_files.push(data);
          callback(data);
          angular.element(document).scope().$apply();
        });
        analytic.owner({
          id: foundry._current_user.id,
          email: foundry._current_user.email,
          date: new Date().getTime(),
          'name': name
        });
      },
      current: function() {
        return window.c_file;
      },
      is_current: function(doc) {
        return doc.id === window.c_file.id;
      },
      rename: function(doc, name, cb) {
        var id, old_name, param, request, self;
        self = this;
        id = doc.id;
        old_name = doc.title;
        param = {
          path: "/drive/v2/files/" + id,
          method: "PATCH",
          params: {
            key: Nimbus.Auth.key,
            fileId: id
          },
          body: {
            title: name
          },
          callback: function(file) {
            var apply_changes, folder, index, query, rename_folder, _file, _ref;
            _ref = window.app_files;
            for (index in _ref) {
              _file = _ref[index];
              if (doc.id === _file.id) {
                file.title = name;
              }
            }
            folder = window.folder.binary_files;
            apply_changes = function(changed_file) {
              if (cb) {
                cb(changed_file);
              }
              return angular.element(document).scope().$apply();
            };
            rename_folder = function(target, replace) {
              return self.rename_folder(target, name + ' files', function(f) {
                if (replace) {
                  window.folder.binary_files = f;
                }
                return apply_changes(file);
              });
            };
            if (c_file.id !== id) {
              query = "mimeType = 'application/vnd.google-apps.folder' and title = '" + old_name + " files' and properties has { key='space' and value='" + id + "' and visibility='PRIVATE' }";
              Nimbus.Client.GDrive.getMetadataList(query, function(data) {
                if (!data.error) {
                  if (data.items.length >= 1) {
                    folder = data.items[0];
                    return rename_folder(folder);
                  } else {
                    return apply_changes();
                  }
                } else {
                  return apply_changes();
                }
              });
            } else {
              rename_folder(folder, true);
            }
          }
        };
        request = gapi.client.request(param);
      },
      rename_folder: function(folder, name, cb) {
        var id, param, request;
        log('rename the folder');
        id = folder.id;
        param = {
          path: "/drive/v2/files/" + id,
          method: "PATCH",
          params: {
            key: Nimbus.Auth.key,
            fileId: id
          },
          body: {
            title: name
          },
          callback: function(file) {
            if (cb) {
              cb(file);
            }
            return angular.element(document).scope().$apply();
          }
        };
        request = gapi.client.request(param);
      },
      del_doc: function(doc, callback) {
        var file, index, _ref, _ref1;
        if (doc.id === c_file.id) {
          return;
        }
        Nimbus.Client.GDrive.deleteFile(doc.id);
        _ref = this._app_files;
        for (index in _ref) {
          file = _ref[index];
          if (doc.id === file.id) {
            this._app_files.splice(index, 1);
          }
        }
        _ref1 = window.app_files;
        for (index in _ref1) {
          file = _ref1[index];
          if (doc.id === file.id) {
            window.app_files.splice(index, 1);
          }
        }
      }
    };
  });

  define_controller = function() {
    return angular.module('foundry').controller('ProjectController', [
      '$scope', '$rootScope', 'ngDialog', '$foundry', function($scope, $rootScope, ngDialog, $foundry) {
        var docModule;
        docModule = foundry.load('workspace');
        $rootScope.breadcum = 'Workspace';
        $scope.filename = '';
        $scope.current_edit = -1;
        $scope.load = function() {
          return $scope.projects = docModule.all_doc();
        };
        $scope.is_loaded = function(doc) {
          return docModule.is_current(doc);
        };
        $scope.add_document = function() {
          $scope.filename = '';
          ngDialog.open({
            template: 'newfile',
            controller: this,
            scope: $scope
          });
        };
        $scope.create_doc = function() {
          var spinner;
          ngDialog.close();
          spinner = $foundry.spinner({
            type: 'loading',
            text: 'Creating ' + $scope.filename + '...'
          });
          docModule.create($scope.filename, function(file) {
            var index, project, _ref;
            if (file.title === $scope.filename) {
              $scope.load();
              spinner.hide();
              _ref = $scope.projects;
              for (index in _ref) {
                project = _ref[index];
                if (file.id === project.id) {
                  $scope["switch"](index);
                  return;
                }
              }
            }
          });
        };
        $scope.edit = function(index) {
          var doc;
          doc = $scope.projects[index];
          $scope.current_edit = index;
          $scope.newname = doc.title;
          ngDialog.open({
            template: 'rename',
            scope: $scope
          });
        };
        $scope["switch"] = function(index) {
          var doc, spinner;
          $scope.current_doc = doc = $scope.projects[index];
          spinner = $foundry.spinner({
            type: 'loading',
            text: 'Switching...'
          });
          docModule.switch_callback = function() {
            $scope.load();
            return spinner.hide();
          };
          docModule.open(doc, function() {});
        };
        $scope.rename = function() {
          var doc, spinner;
          doc = $scope.projects[$scope.current_edit];
          spinner = $foundry.spinner({
            type: 'loading',
            text: 'Renaming...'
          });
          ngDialog.close();
          docModule.rename(doc, $scope.newname, function(file) {
            console.log(file);
            $scope.load();
            return spinner.hide();
          });
        };
        $scope.delet_doc = function(index) {
          var doc;
          doc = $scope.projects[index];
          docModule.del_doc(doc);
        };
        $scope.load();
      }
    ]);
  };

}).call(this);

// Generated by CoffeeScript 1.8.0

/*
    angular directives
 */

(function() {
  angular.module('foundry-ui', ['ngDialog']).directive('enEditor', [
    '$parse', '$timeout', function($parse, $timeout) {
      return function(scope, elm, attrs) {
        var composer, editor, iframe, update, value;
        value = $parse(attrs.ngModel)(scope);
        update = function() {
          var getter, setter;
          getter = $parse(elm.attr('ng-model'));
          setter = getter.assign;
          setter(angular.element(elm).scope(), $(elm).val());

          /*
              compare the value if is the same, we should not update.
           */
          return $timeout(function() {
            return angular.element(elm).scope().$apply();
          }, 0);
        };
        editor = $(elm).wysihtml5($.extend(foundry.wysiwygOptions, {
          stylesheets: [],
          events: {
            'change': update,
            'blur': update
          }
        }));
        scope.$watch(attrs.ngModel, function(value) {
          if (!value) {
            value = '';
          }
          if (value !== $(elm).data("wysihtml5").editor.composer.getValue()) {
            $(elm).data("wysihtml5").editor.composer.setValue(value);
          }
        }, true);
        iframe = $(elm).data("wysihtml5").editor.currentView.iframe;
        composer = $(elm).data("wysihtml5").editor.composer;
        $(iframe).on('load', function() {
          $(iframe.contentDocument.body).on('keydown', function(evt) {
            if (evt.keyCode === 13) {
              composer.selectedNodeBeforeReturn = composer.selection.getSelectedNode();
              return composer.commands.exec("insertHTML", '<br>');
            }
          });
          return $(iframe.contentDocument.body).on('paste', function(evt) {
            console.log('pasted');
            return evt.stopPropagation();
          });
        });
        if (!value) {
          value = '';
        }
        $(elm).data("wysihtml5").editor.composer.setValue(value);
      };
    }
  ]).directive('modelForm', [
    '$compile', '$parse', function($compile, $parse) {
      return {
        restrict: 'E',
        compile: function(tElement, tAttr) {
          return function(scope, element, attrs) {
            var content, create_method, html, instance, k, key, mode, model, random, update_method, v, value, _ref, _ref1;
            random = Math.floor(Math.random() * 1000000000);
            instance = attrs['instanceName'];
            model = attrs['modelName'];
            create_method = scope[model].create;
            update_method = scope[model].update;
            html = '<form>';
            mode = attrs['formMode'];
            _ref = scope[model].fields;
            for (key in _ref) {
              value = _ref[key];
              html += '<div class="nimb_form' + (" " + value.type) + '"';
              if (value.show) {
                html += 'ng-show="' + value.show + '"';
              }
              if (value.hide) {
                html += 'ng-hide="' + value.hide + '"';
              }
              html += '>';
              html += '<label for="' + instance + '.' + key + random + '">' + value.label + '</label>';
              switch (value.type) {
                case 'input':
                  html += '<input type="text" id="' + instance + '.' + key + random + '" ng-model="' + instance + '.' + key + '">';
                  break;
                case 'select':
                  html += '<select ng-model="' + instance + '.' + key + '">';
                  _ref1 = value.options;
                  for (k in _ref1) {
                    v = _ref1[k];
                    html += '<option ng-selected="' + model + '.' + key + '.value == ' + v + '" value="' + v + '">' + k + '</option>';
                  }
                  html += '</select>';
                  break;
                case 'checkbox':
                  html += '<div class="checker"><span><input style="margin-top:0px;margin-right:10px;" type="checkbox" ng-model="' + instance + '.' + key + '" >' + value.text + '</span></div><br>';
                  break;
                case 'text':
                  html += '<textarea id="' + instance + '.' + key + random + '" ng-model="' + instance + '.' + key + '"></textarea>';
                  break;
                case 'editor':
                  html += '<textarea style="" en-editor ng-model="' + instance + '.' + key + '">{{' + instance + '[key]}}</textarea>';
                  break;
                case 'list':
                  html += '<span ng-init="' + instance + '.' + key + '=[]||' + instance + '.' + key + '"></span>';
                  html += '<tags-input custom-class="bootstrap" type="text" ng-model="' + instance + '.' + key + '"></tags-input>';
                  break;
                case 'radio':
                  html += '<div><label ng-repeat="(k,v) in ' + model + '.' + key + '.options">';
                  html += '<input name="' + instance + '.' + key + '" style="margin-top: -4px;margin-right: 5px;" type="radio" value="{{v}}" ng-model="' + instance + '.' + key + '"> {{k}}<br />';
                  html += '</label></div>';
                  break;
                case 'file':
                  html += '<span class="btn outline btn-file"><input type="file" form-file en-model="' + instance + '.' + key + '" class="fileupload">Choose File</span>';
                  html += '<span class="btn btn-danger" ng-show="' + instance + '.' + key + '" ng-click="' + instance + '.' + key + '=null">Clear</span>';
                  html += '<p class="file_attach">{{' + instance + '.' + key + '.name}}</p>';
                  break;
                case 'date_time':
                  html += '<input class="datetimepicker" en-date type="text" ng-model="' + instance + '.' + key + '">';
              }
              html += '</div>';
            }
            html += '<button ng-show="' + mode + '==' + "'" + 'edit' + "'" + '" class="btn btn-success update_button" ng-click="' + update_method + '">Update</button>';
            html += '<button ng-show="' + mode + '==' + "'" + 'create' + "'" + '" class="btn btn-primary create_button" ng-click="' + create_method + '">Create</button>';
            html += '</form>';
            content = $compile(html)(scope);
            element.replaceWith(content);
          };
        }
      };
    }
  ]).directive('enList', [
    '$compile', '$timeout', '$parse', function($compile, $timeout, $parse) {
      return function(scope, elm, attrs) {
        $timeout(function() {
          return $(elm).simpleTagger();
        }, 300);
        scope.$watch(attrs.ngModel, function(oldValue, newValue) {
          return console.log('new value');
        });
        return console.log('list directive');
      };
    }
  ]).directive('userInfo', [
    '$compile', function($compile) {
      return {
        restrict: 'E',
        compile: function(tElement, tAttr) {
          return function(scope, element, attrs) {
            return console.log($compile);
          };
        }
      };
    }
  ]).directive("fileread", [
    function() {
      return {
        link: function($scope, element, attrs) {
          element.bind("change", function(evt) {
            if (attrs.enModel) {
              $scope[attrs.enModel] = evt.target.files[0];
              return $scope.$apply();
            }
          });
          element.on('click', function(evt) {
            return evt.stopPropagation();
          });
        }
      };
    }
  ]).directive('formFile', [
    '$parse', function($parse) {
      return function(scope, elm, attrs) {
        var changed, setter;
        setter = 'test';
        changed = function(evt) {
          var getter;
          if (attrs.enModel) {
            getter = $parse(attrs.enModel);
            setter = getter.assign;
            setter(scope, evt.target.files[0]);
            return scope.$apply();
          }
        };
        return elm.bind("change", changed);
      };
    }
  ]).factory('$foundry', [
    '$http', function($http) {
      var service;
      service = {
        email: function() {
          var mailgun;
          console.log('email');
          mailgun = function(type, value, content, bcc, cc) {
            var form_data;
            form_data = {
              'from': encodeURIComponent('NimbusBase <me@nimbusbase.com>'),
              'to': encodeURIComponent(value),
              'subject': encodeURIComponent(type),
              'html': encodeURIComponent(content)
            };
            if (bcc) {
              form_data['bcc'] = encodeURIComponent(bcc);
            }
            if (cc) {
              form_data['cc'] = encodeURIComponent(cc);
            }
            return $.ajax({
              url: 'http://192.241.167.76:3000/api.mailgun.net/v2/nimbusbase.com/messages',
              method: 'post',
              beforeSend: function(request) {
                return request.setRequestHeader("Authorization", "Basic  YXBpOmtleS04c3RvbXM1eGwtaHRuZGFoMmZsNGNycG9vaTN0bnllMg==");
              },
              data: form_data,
              success: function(data) {
                return console.log(data);
              }
            });
          };
          return mailgun.apply(this, arguments);
        },
        gmail: function(subject, to, content, cc, bcc) {
          var base64EncodedEmail, data, mailCallback, sendMessage;
          if (cc == null) {
            cc = '';
          }
          if (bcc == null) {
            bcc = '';
          }
          base64EncodedEmail = "";
          sendMessage = function(email, callback) {
            var request;
            base64EncodedEmail = base64EncArr(strToUTF8Arr(email)).replace(/\//g, "_").replace(/\+/g, "-");
            request = gapi.client.gmail.users.messages.send({
              'userId': 'me',
              'message': {
                'raw': base64EncodedEmail
              }
            });
            return request.execute(callback);
          };
          mailCallback = function(error, email) {
            var currentUserEmail;
            if (error) {
              console.log(error);
              return;
            }
            currentUserEmail = foundry._current_user.email;
            return sendMessage(email, function() {
              var cto, originalCc, retry, toList, _i, _len, _results;
              console.log(arguments);
              if (arguments[0].code === 400 && arguments[0].message === "Invalid cc header") {
                console.log("sent failure for multiple cc, try to send email one by one");
                retry = true;
                originalCc = data.cc;
                data.cc = null;
                window.composeMail(data, mailCallback);
                toList = originalCc.split(",");
                _results = [];
                for (_i = 0, _len = toList.length; _i < _len; _i++) {
                  cto = toList[_i];
                  data.to = cto;
                  _results.push(window.composeMail(data, mailCallback));
                }
                return _results;
              }

              /*if arguments[0].id
                  if to.indexOf(currentUserEmail)>=0 or bcc.indexOf(currentUserEmail)>=0 or cc.indexOf(currentUserEmail)>=0
                      gapi.client.request({
                          path:"gmail/v1/users/me/messages/#{arguments[0].id}/modify"
                          method: "POST"
                          body:"{\"addLabelIds\": [\"UNREAD\",\"INBOX\"]}"
                          callback: () ->
                              console.log ("gmail sent to self")
                              console.log(arguments)
                      })
               */
            });
          };
          data = {
            'from': "'" + foundry._current_user.name + "'<" + foundry._current_user.email + ">",
            'to': to,
            'cc': cc,
            'bcc': bcc,
            'subject': subject,
            'html': content
          };
          if (window.composeMail) {
            return window.composeMail(data, mailCallback);
          } else {
            return window.mailTasks.push(data, mailCallback);
          }
        },
        validate: function(emal, callback) {
          console.log('validation');
          return Nimbus.Share.add_share_user_real(email, function(user) {
            var is_valid;
            is_valid = user.name ? true : false;
            Nimbus.Share.remove_share_user_real(user.id, function(res) {
              return callback(is_valid);
            });
          });
        },
        spinner: function(config) {
          var data, opts, spinner, target;
          data = {
            text: config.text
          };
          switch (config.type) {
            case 'loading':
              opts = {
                lines: 13,
                length: 11,
                width: 5,
                radius: 17,
                corners: 1,
                rotate: 0,
                color: '#FFF',
                speed: 1,
                trail: 60,
                shadow: false,
                hwaccel: false,
                className: 'spinner',
                zIndex: 2e9,
                top: 'auto',
                left: 'auto'
              };
              target = document.createElement("div");
              document.body.appendChild(target);
              spinner = new Spinner(opts).spin(target);
              data.spinner = spinner;
              break;
            case 'sucess':
              data.icon = 'img/check.png';
              break;
            case 'error':
              data.icon = 'img/cross.png';
          }
          return iosOverlay(data);
        },
        rss: function(url, callback) {
          var buildUrl, callbackWhenMatch, httpsProxyUrl, matchArticle, proxyUrl, retrieveArticle;
          proxyUrl = httpsProxyUrl = 'http://192.241.167.76:9292/';
          callbackWhenMatch = null;
          buildUrl = function(str) {
            var https;
            https = str.indexOf('https://');
            if (https === -1) {
              str = proxyUrl + str.replace('http://', '');
            } else {
              str = httpsProxyUrl + str.replace('https://', '');
            }
            return str;
          };
          matchArticle = function(options) {
            var article, callbackOrNot, listUrl, title;
            article = options.rss;
            listUrl = options.url;
            callbackOrNot = options.callback;
            title = options.title;
            return $.ajax({
              url: buildUrl(listUrl),
              dataType: 'xml',
              success: function(data) {
                var error, item, list, obj, _i, _len;
                list = $(data).find('item');
                if (list.length === 0) {
                  list = $(data).find('entry');
                }
                obj = null;
                error = true;
                for (_i = 0, _len = list.length; _i < _len; _i++) {
                  item = list[_i];
                  if ($(item).find('link').text().indexOf(article) !== -1) {
                    obj = item;
                    error = false;
                    break;
                  }
                  if (title && title.indexOf($(item).find('title').text()) !== -1) {
                    obj = item;
                    error = false;
                    break;
                  }
                }
                if (error) {
                  obj = {
                    'title': title
                  };
                }
                if (callbackOrNot) {
                  return callbackWhenMatch(obj, error);
                }
              },
              error: function(req, text) {
                var data, error, item, list, obj, _i, _len;
                console.log(req, text);
                data = null;
                if (text === 'parsererror') {
                  data = $(req.responseText);
                }
                list = $(data).find('item');
                if (list.length === 0) {
                  list = $(data).find('entry');
                }
                obj = null;
                error = true;
                for (_i = 0, _len = list.length; _i < _len; _i++) {
                  item = list[_i];
                  if ($(item).find('link').text().indexOf(article) !== -1) {
                    obj = item;
                    error = false;
                    break;
                  }
                  if (title && title.indexOf($(item).find('title').text()) !== -1) {
                    obj = item;
                    error = false;
                    break;
                  }
                }
                if (error) {
                  obj = {
                    'title': title
                  };
                }
                if (callbackOrNot) {
                  return callbackWhenMatch(obj, error);
                }
              }
            });
          };
          retrieveArticle = function(rss, callback) {
            var str;
            str = buildUrl(rss);
            callbackWhenMatch = callback;
            return $.ajax({
              url: str,
              async: false,
              dataType: 'html',
              success: function(data) {
                var listUrl, match, options, titleMatch;
                titleMatch = /<title>([\s\S]*)<\/title>/.exec(data);
                match = /application\/rss\+xml.*href=['"](.*)['"]/.exec(data);
                if (match && match.length >= 2) {
                  listUrl = match[1];
                  if (listUrl.indexOf('feedburner.com') !== -1) {
                    listUrl = listUrl + '?format=xml';
                  }
                  options = {
                    'url': listUrl,
                    'rss': rss,
                    'title': titleMatch[1] || '',
                    'callback': true
                  };
                  return matchArticle(options);
                } else {
                  console.log('error when get this site');
                  data = {
                    title: titleMatch[1] || ''
                  };
                  return callbackWhenMatch(data, true);
                }
              },
              error: function(data) {
                console.log(data);
                return callbackWhenMatch(null, true);
              }
            });
          };
          retrieveArticle(url, callback);
        }
      };
      return service;
    }
  ]).directive('enCalendar', [
    '$parse', function($parse) {
      var link;
      link = function(scope, elm, attrs) {
        var config;
        config = {};
        if (attrs['enClick']) {
          config.action = function(evt) {
            var id;
            id = evt.target.id.replace('_day', '');
            $(elm).find('.current_date').removeClass('current_date');
            $('#' + id).addClass('current_date');
            scope.show_date.call(scope, evt);
            return scope.$apply();
          };
        }
        $(elm).zabuto_calendar(config);
        scope.$watch('selected_date', function(n, o) {
          if (!n || n === '') {
            return $(elm).find('.current_date').removeClass('current_date');
          }
        });
      };
      return {
        link: link
      };
    }
  ]).directive('bindHtmlUnsafe', [
    '$compile', function($compile) {
      return function($scope, $element, $attrs) {
        var compile, htmlName;
        compile = function(newHTML) {
          if (newHTML) {
            newHTML = newHTML.replace(/\n/g, '<br>');
          }
          return $element.html('').append(newHTML);
        };
        htmlName = $attrs.bindHtmlUnsafe;
        return $scope.$watch(htmlName, function(newHTML, oldHTML) {
          return compile(newHTML);
        });
      };
    }
  ]).directive('confirm', [
    '$compile', function($compile) {
      return {
        link: function($scope, elm, attrs) {
          return elm.bind('click', function(evt) {
            var content, html, onCancel, onConfirm;
            onConfirm = attrs['onConfirm'];
            onCancel = attrs['onCancel'] ? attrs['onCancel'] : '';
            html = '<div class="wrapper dismiss_containter"><form>';
            html += '<div class="m-t-lg text-right"><button style="margin-right:5px" en-dismiss ng-click="' + onConfirm + '" class="btn btn-success">Yes</button>';
            html += '<button class="btn btn-danger bootbox-close-button" en-dismiss ng-click="' + onCancel + '">No</button></div>';
            html += '</form></div>';
            content = $compile(html)($scope);
            bootbox.dialog({
              'title': 'Are you sure you want to do this?',
              'className': "nimbus_confirm_modal",
              'message': content
            });
          });
        }
      };
    }
  ]).directive('enDismiss', function() {
    return function(scope, elm, attrs) {
      return elm.bind('click', function(evt) {
        return bootbox.hideAll();
      });
    };
  }).directive('subexternal', function() {
    return {
      link: function(scope, elm, attrs) {
        return elm.delegate('a', 'click', function(evt) {
          var targetURL;
          if (!this.href || this.href.indexOf('#') === 0) {
            return;
          }
          evt.preventDefault();
          targetURL = this.href;
          return window.open(targetURL, "_blank");
        });
      }
    };
  }).directive('enDate', function() {
    return function(scope, elm, attrs) {
      return $(elm).datetimepicker();
    };
  }).directive('enEditInPlace', [
    '$parse', '$compile', function($parse, $compile) {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, elm, attrs, ngModel) {
          var edit, listener;
          edit = $("<div contentEditable='true' class='temp tasks-list-desc editable-cell' style='top:0px;text-decoration:none'></div>");
          listener = function(evt) {
            var editable, value;
            value = $parse(attrs['ngModel'])(scope);
            editable = $parse(attrs['enableEdit'])(scope);
            evt.stopPropagation();
            if (editable) {
              return;
            }
            elm.after(edit.html(value)).hide();
            edit.focus();
            edit.on('blur', function(evt) {
              return elm.show().next('.temp').remove();
            });
            return edit.on('keydown', function(evt) {
              if (evt.keyCode === 13) {
                scope.$apply(function() {
                  return elm.controller('ngModel').$setViewValue(edit.text());
                });
                return elm.show().next('.temp').remove();
              }
            });
          };
          elm.on('click', listener);
        }
      };
    }
  ]).directive('enZoom', [
    function() {
      return function(scope, elm, attrs) {
        var url;
        url = attrs['enZoom'];
        return elm.on('click', function(evt) {
          var html, modal;
          html = '<div class="image-zoomed todo-image-zoomed">';
          html += "<img src='" + url + "' />";
          html += '<div class="backdrop"></div>';
          html += '</div>';
          modal = $(html);
          modal.on('click', function(evt) {
            return $(this).fadeOut(function() {
              return $(this).remove();
            });
          });
          return $('body').append(modal.fadeIn());
        });
      };
    }
  ]).directive('imgZoom', function() {
    return {
      link: function(scope, elm, attrs) {
        var show_pop_up;
        elm.delegate('img', 'mouseenter', function(evt) {
          var link, url;
          url = evt.target.src;
          link = "<div class='mask'></div><a class='zoom-action-button' data-src='" + url + "'><i class='icon icon-zoom-in'></i></a>";
          $(evt.target).wrap('<p class="image-zoom-container"></p>');
          return $(evt.target).parent().append(link);
        });
        elm.delegate('img', 'mouseleave', function(evt) {
          $(evt.target).children('a,div.mask').remove();
          $(evt.target).siblings('a,div.mask').remove();
          return $(evt.target).unwrap();
        });
        elm.delegate('.zoom-action-button', 'click', function(evt) {
          var url;
          url = $(evt.target).data('src');
          return show_pop_up(url);
        });
        show_pop_up = function(url) {
          var html, modal;
          html = '<div class="image-zoomed todo-image-zoomed">';
          html += "<img src='" + url + "' />";
          html += '<div class="backdrop"></div>';
          html += '</div>';
          modal = $(html);
          modal.on('click', function(evt) {
            return $(this).fadeOut(function() {
              return $(this).remove();
            });
          });
          return $('body').append(modal.fadeIn());
        };
        return console.log('in link stage');
      }
    };
  }).directive('subZoom', function() {
    return function(scope, elm, attrs) {
      var show_pop_up;
      elm.delegate('img', 'click', function(evt) {
        var url;
        url = evt.target.src;
        return show_pop_up(url);
      });
      return show_pop_up = function(url) {
        var html, modal;
        html = '<div class="image-zoomed todo-image-zoomed">';
        html += "<img src='" + url + "' />";
        html += '<div class="backdrop"></div>';
        html += '</div>';
        modal = $(html);
        modal.on('click', function(evt) {
          return $(this).fadeOut(function() {
            return $(this).remove();
          });
        });
        return $('body').append(modal.fadeIn());
      };
    };
  }).directive('rssFeed', function() {
    return function(scope, elm, attrs) {};
  });

  angular.module("foundry-ui").directive("enFile", [
    '$parse', function($parse) {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          element.on("change", function(evt) {
            var setter;
            if (attrs.enModel) {
              setter = $parse(attrs.enModel).assign;
              setter(scope, evt.target.files[0]);
            }
            return scope.$apply();
          });
          element.on('click', function(evt) {
            return evt.stopPropagation();
          });
        }
      };
    }
  ]);

}).call(this);

// Generated by CoffeeScript 1.8.0
angular.module('foundry-ui').filter('utc_date', function() {
  return function(input, format) {
    var out;
    out = new Date(input);
    out = out.toDateString();
    return out;
  };
});
